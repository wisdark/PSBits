#include <Windows.h>
#include <tchar.h>

#define GUID_1 _T("1cbed8d1-b5d1-4441-857d-a2c122514b3e")

typedef HANDLE FW_IO_POLICY_STORE_HANDLE;
typedef int FW_RULE_TYPE;

#define FW_RULE_TYPE_FIREWALL 0
#define FW_RULE_FLAGS_ACTIVE 1U
#define TCP_PROTOCOL_NUMBER 6
#define UDP_PROTOCOL_NUMBER 17

HMODULE hFwpolicyiomgrDLL;

typedef struct _tag_FW_BLOB_RULE
{
	struct _tag_FW_BLOB_RULE* pNext;
} FW_BLOB_RULE, *PFW_BLOB_RULE;

typedef enum _tag_FW_STORE_TYPE
{
	FW_STORE_TYPE_LOCAL = 2
} FW_STORE_TYPE;

typedef enum _tag_FW_POLICY_ACCESS_RIGHT
{
	FW_POLICY_ACCESS_RIGHT_READ = 1
} FW_POLICY_ACCESS_RIGHT;

typedef enum _tag_FW_PROFILE_TYPE
{
	FW_PROFILE_TYPE_ALL = 0x7FFFFFFF
} FW_PROFILE_TYPE;


typedef enum _tag_FW_DIRECTION
{
	FW_DIR_INVALID = 0,
	FW_DIR_IN,
	FW_DIR_OUT,
	FW_DIR_MAX
} FW_DIRECTION;

typedef struct _tag_FW_PORT_RANGE
{
	unsigned short wBegin;
	unsigned short wEnd;
} FW_PORT_RANGE, *PFW_PORT_RANGE;

typedef struct _tag_FW_PORT_RANGE_LIST
{
	unsigned long dwNumEntries;
	PFW_PORT_RANGE pPorts;
} FW_PORT_RANGE_LIST, *PFW_PORT_RANGE_LIST;

typedef struct _tag_FW_PORTS
{
	unsigned short wPortKeywords;
	FW_PORT_RANGE_LIST Ports;
} FW_PORTS, *PFW_PORTS;

typedef struct _tag_FW_ICMP_TYPE_CODE
{
	unsigned char bType;
	unsigned short wCode;
} FW_ICMP_TYPE_CODE, *PFW_ICMP_TYPE_CODE;

typedef struct _tag_FW_ICMP_TYPE_CODE_LIST
{
	unsigned long dwNumEntries;
	PFW_ICMP_TYPE_CODE pEntries;
} FW_ICMP_TYPE_CODE_LIST, *PFW_ICMP_TYPE_CODE_LIST;

typedef struct _tag_FW_IPV4_SUBNET
{
	unsigned long dwAddress;
	unsigned long dwSubNetMask;
} FW_IPV4_SUBNET, *PFW_IPV4_SUBNET;

typedef struct _tag_FW_IPV4_SUBNET_LIST
{
	unsigned long dwNumEntries;
	PFW_IPV4_SUBNET pSubNets;
} FW_IPV4_SUBNET_LIST, *PFW_IPV4_SUBNET_LIST;

typedef struct _tag_FW_IPV4_ADDRESS_RANGE
{
	unsigned long dwBegin;
	unsigned long dwEnd;
} FW_IPV4_ADDRESS_RANGE, *PFW_IPV4_ADDRESS_RANGE;

typedef struct _tag_FW_IPV4_RANGE_LIST
{
	unsigned long dwNumEntries;
	PFW_IPV4_ADDRESS_RANGE pRanges;
} FW_IPV4_RANGE_LIST, *PFW_IPV4_RANGE_LIST;

typedef struct _tag_FW_IPV6_SUBNET
{
	unsigned char Address[16];
	unsigned long dwNumPrefixBits;
} FW_IPV6_SUBNET, *PFW_IPV6_SUBNET;

typedef struct _tag_FW_IPV6_SUBNET_LIST
{
	unsigned long dwNumEntries;
	PFW_IPV6_SUBNET pSubNets;
} FW_IPV6_SUBNET_LIST, *PFW_IPV6_SUBNET_LIST;

typedef struct _tag_FW_IPV6_ADDRESS_RANGE
{
	unsigned char Begin[16];
	unsigned char End[16];
} FW_IPV6_ADDRESS_RANGE, *PFW_IPV6_ADDRESS_RANGE;

typedef struct _tag_FW_IPV6_RANGE_LIST
{
	unsigned long dwNumEntries;
	PFW_IPV6_ADDRESS_RANGE pRanges;
} FW_IPV6_RANGE_LIST, *PFW_IPV6_RANGE_LIST;

typedef struct _tag_FW_ADDRESSES
{
	unsigned long dwV4AddressKeywords;
	unsigned long dwV6AddressKeywords;
	FW_IPV4_SUBNET_LIST V4SubNets;
	FW_IPV4_RANGE_LIST V4Ranges;
	FW_IPV6_SUBNET_LIST V6SubNets;
	FW_IPV6_RANGE_LIST V6Ranges;
} FW_ADDRESSES, *PFW_ADDRESSES;

typedef struct _tag_FW_INTERFACE_LUIDS
{
	unsigned long dwNumLUIDs;
	GUID* pLUIDs;
} FW_INTERFACE_LUIDS, *PFW_INTERFACE_LUIDS;

typedef enum _tag_FW_RULE_ACTION
{
	FW_RULE_ACTION_INVALID = 0,
	FW_RULE_ACTION_ALLOW_BYPASS = 1,
	FW_RULE_ACTION_BLOCK = 2,
	FW_RULE_ACTION_ALLOW = 3,
	FW_RULE_ACTION_MAX = 4
} FW_RULE_ACTION;

typedef struct _tag_FW_OS_PLATFORM
{
	unsigned char bPlatform;
	unsigned char bMajorVersion;
	unsigned char bMinorVersion;
	unsigned char Reserved;
} FW_OS_PLATFORM, *PFW_OS_PLATFORM;

typedef struct _tag_FW_OS_PLATFORM_LIST
{
	unsigned long dwNumEntries;
	PFW_OS_PLATFORM pPlatforms;
} FW_OS_PLATFORM_LIST, *PFW_OS_PLATFORM_LIST;

typedef enum _tag_FW_RULE_STATUS
{
	FW_RULE_STATUS_OK = 0x00010000,
	FW_RULE_STATUS_PARTIALLY_IGNORED = 0x00020000,
	FW_RULE_STATUS_IGNORED = 0x00040000,
	FW_RULE_STATUS_PARSING_ERROR = 0x00080000,
	FW_RULE_STATUS_PARSING_ERROR_NAME = 0x00080001,
	FW_RULE_STATUS_PARSING_ERROR_DESC = 0x00080002,
	FW_RULE_STATUS_PARSING_ERROR_APP = 0x00080003,
	FW_RULE_STATUS_PARSING_ERROR_SVC = 0x00080004,
	FW_RULE_STATUS_PARSING_ERROR_RMA = 0x00080005,
	FW_RULE_STATUS_PARSING_ERROR_RUA = 0x00080006,
	FW_RULE_STATUS_PARSING_ERROR_EMBD = 0x00080007,
	FW_RULE_STATUS_PARSING_ERROR_RULE_ID = 0x00080008,
	FW_RULE_STATUS_PARSING_ERROR_PHASE1_AUTH = 0x00080009,
	FW_RULE_STATUS_PARSING_ERROR_PHASE2_CRYPTO = 0x0008000A,
	FW_RULE_STATUS_PARSING_ERROR_PHASE2_AUTH = 0x0008000B,
	FW_RULE_STATUS_PARSING_ERROR_RESOLVE_APP = 0x0008000C,
	FW_RULE_STATUS_PARSING_ERROR_MAINMODE_ID = 0x0008000D,
	FW_RULE_STATUS_PARSING_ERROR_PHASE1_CRYPTO = 0x0008000E,
	FW_RULE_STATUS_PARSING_ERROR_REMOTE_ENDPOINTS = 0x0008000F,
	FW_RULE_STATUS_PARSING_ERROR_REMOTE_ENDPOINT_FQDN = 0x00080010,
	FW_RULE_STATUS_PARSING_ERROR_KEY_MODULE = 0x00080011,
	FW_RULE_STATUS_PARSING_ERROR_LUA = 0x00080012,
	FW_RULE_STATUS_PARSING_ERROR_FWD_LIFETIME = 0x00080013,
	FW_RULE_STATUS_PARSING_ERROR_TRANSPORT_MACHINE_AUTHZ_SDDL = 0x00080014,
	FW_RULE_STATUS_PARSING_ERROR_TRANSPORT_USER_AUTHZ_SDDL = 0x00080015,
	FW_RULE_STATUS_PARSING_ERROR_NETNAMES_STRING = 0x00080016,
	FW_RULE_STATUS_PARSING_ERROR_SECURITY_REALM_ID_STRING = 0x00080017,
	FW_RULE_STATUS_PARSING_ERROR_FQBN_STRING = 0x00080018,
	FW_RULE_STATUS_SEMANTIC_ERROR = 0x00100000,
	FW_RULE_STATUS_SEMANTIC_ERROR_RULE_ID = 0x00100010,
	FW_RULE_STATUS_SEMANTIC_ERROR_PORTS = 0x00100020,
	FW_RULE_STATUS_SEMANTIC_ERROR_PORT_KEYW = 0x00100021,
	FW_RULE_STATUS_SEMANTIC_ERROR_PORT_RANGE = 0x00100022,
	FW_RULE_STATUS_SEMANTIC_ERROR_PORTRANGE_RESTRICTION = 0x00100023,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4_SUBNETS = 0x00100040,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6_SUBNETS = 0x00100041,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4_RANGES = 0x00100042,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6_RANGES = 0x00100043,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_RANGE = 0x00100044,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_MASK = 0x00100045,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_PREFIX = 0x00100046,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_KEYW = 0x00100047,
	FW_RULE_STATUS_SEMANTIC_ERROR_LADDR_PROP = 0x00100048,
	FW_RULE_STATUS_SEMANTIC_ERROR_RADDR_PROP = 0x00100049,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V6 = 0x0010004A,
	FW_RULE_STATUS_SEMANTIC_ERROR_LADDR_INTF = 0x0010004B,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_V4 = 0x0010004C,
	FW_RULE_STATUS_SEMANTIC_ERROR_TUNNEL_ENDPOINT_ADDR = 0x0010004D,
	FW_RULE_STATUS_SEMANTIC_ERROR_DTE_VER = 0x0010004E,
	FW_RULE_STATUS_SEMANTIC_ERROR_DTE_MISMATCH_ADDR = 0x0010004F,
	FW_RULE_STATUS_SEMANTIC_ERROR_PROFILE = 0x00100050,
	FW_RULE_STATUS_SEMANTIC_ERROR_ICMP = 0x00100060,
	FW_RULE_STATUS_SEMANTIC_ERROR_ICMP_CODE = 0x00100061,
	FW_RULE_STATUS_SEMANTIC_ERROR_IF_ID = 0x00100070,
	FW_RULE_STATUS_SEMANTIC_ERROR_IF_TYPE = 0x00100071,
	FW_RULE_STATUS_SEMANTIC_ERROR_ACTION = 0x00100080,
	FW_RULE_STATUS_SEMANTIC_ERROR_ALLOW_BYPASS = 0x00100081,
	FW_RULE_STATUS_SEMANTIC_ERROR_DO_NOT_SECURE = 0x00100082,
	FW_RULE_STATUS_SEMANTIC_ERROR_ACTION_BLOCK_IS_ENCRYPTED_SECURE = 0x00100083,
	FW_RULE_STATUS_SEMANTIC_ERROR_INCOMPATIBLE_FLAG_OR_ACTION_WITH_SECURITY_REALM = 0x00100084,
	FW_RULE_STATUS_SEMANTIC_ERROR_DIR = 0x00100090,
	FW_RULE_STATUS_SEMANTIC_ERROR_PROT = 0x001000A0,
	FW_RULE_STATUS_SEMANTIC_ERROR_PROT_PROP = 0x001000A1,
	FW_RULE_STATUS_SEMANTIC_ERROR_DEFER_EDGE_PROP = 0x001000A2,
	FW_RULE_STATUS_SEMANTIC_ERROR_ALLOW_BYPASS_OUTBOUND = 0x001000A3,
	FW_RULE_STATUS_SEMANTIC_ERROR_DEFER_USER_INVALID_RULE = 0x001000A4,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS = 0x001000B0,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_AUTH = 0x001000B1,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_BLOCK = 0x001000B2,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTO_DYN_RPC = 0x001000B3,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTHENTICATE_ENCRYPT = 0x001000B4,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE_VER = 0x001000B5,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE = 0x001000B6,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ESP_NO_ENCAP_VER = 0x001000B7,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ESP_NO_ENCAP = 0x001000B8,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_TUNNEL_AUTH_MODES_VER = 0x001000B9,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_TUNNEL_AUTH_MODES = 0x001000BA,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_IP_TLS_VER = 0x001000BB,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_PORTRANGE_VER = 0x001000BC,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ADDRS_TRAVERSE_DEFER_VER = 0x001000BD,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTH_WITH_ENC_NEGOTIATE_OUTBOUND = 0x001000BE,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_AUTHENTICATE_WITH_OUTBOUND_BYPASS_VER = 0x001000BF,
	FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_AUTH_LIST = 0x001000C0,
	FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_USER_LIST = 0x001000C1,
	FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_LIST = 0x001000C2,
	FW_RULE_STATUS_SEMANTIC_ERROR_LUA_VER = 0x001000C3,
	FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_OWNER = 0x001000C4,
	FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_USER_OWNER_VER = 0x001000C5,
	FW_RULE_STATUS_SEMANTIC_ERROR_LUA_CONDITIONAL_VER = 0x001000C6,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_SYSTEMOS_GAMEOS = 0x001000C7,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_CORTANA_VER = 0x001000C8,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_REMOTENAME = 0x001000C9,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_ALLOW_PROFILE_CROSSING_VER = 0x001000D0,
	FW_RULE_STATUS_SEMANTIC_ERROR_LOCAL_ONLY_MAPPED_VER = 0x001000D1,
	FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM = 0x001000E0,
	FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM_OP_VER = 0x001000E1,
	FW_RULE_STATUS_SEMANTIC_ERROR_PLATFORM_OP = 0x001000E2,
	FW_RULE_STATUS_SEMANTIC_ERROR_DTE_NOANY_ADDR = 0x001000F0,
	FW_RULE_STATUS_SEMANTIC_TUNNEL_EXEMPT_WITH_GATEWAY = 0x001000F1,
	FW_RULE_STATUS_SEMANTIC_TUNNEL_EXEMPT_VER = 0x001000F2,
	FW_RULE_STATUS_SEMANTIC_ERROR_ADDR_KEYWORD_VER = 0x001000F3,
	FW_RULE_STATUS_SEMANTIC_ERROR_KEY_MODULE_VER = 0x001000F4,
	FW_RULE_STATUS_SEMANTIC_ERROR_APP_CONTAINER_PACKAGE_ID = 0x00100100,
	FW_RULE_STATUS_SEMANTIC_ERROR_APP_CONTAINER_PACKAGE_ID_VER = 0x00100101,
	FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_INCOMPATIBLE = 0x00100200,
	FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_INVALID = 0x00100201,
	FW_RULE_STATUS_SEMANTIC_ERROR_TRUST_TUPLE_KEYWORD_VER = 0x00100202,
	FW_RULE_STATUS_SEMANTIC_ERROR_INTERFACE_TYPES_VER = 0x00100301,
	FW_RULE_STATUS_SEMANTIC_ERROR_NETNAMES_VER = 0x00100401,
	FW_RULE_STATUS_SEMANTIC_ERROR_SECURITY_REALM_ID_VER = 0x00100402,
	FW_RULE_STATUS_SEMANTIC_ERROR_SYSTEMOS_GAMEOS_VER = 0x00100403,
	FW_RULE_STATUS_SEMANTIC_ERROR_DEVMODE_VER = 0x00100404,
	FW_RULE_STATUS_SEMANTIC_ERROR_REMOTE_SERVERNAME_VER = 0x00100405,
	FW_RULE_STATUS_SEMANTIC_ERROR_FQBN_VER = 0x00100406,
	FW_RULE_STATUS_SEMANTIC_ERROR_COMPARTMENT_ID_VER = 0x00100407,
	FW_RULE_STATUS_SEMANTIC_ERROR_CALLOUT_AND_AUDIT_VER = 0x00100408,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_AUTH_SET_ID = 0x00100500,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_SET_ID = 0x00100510,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_SET_ID = 0x00100511,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_KEY_MANAGER_DICTATE_VER = 0x00100512,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_KEY_MANAGER_NOTIFY_VER = 0x00100513,
	FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_MACHINE_AUTHZ_VER = 0x00100514,
	FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_USER_AUTHZ_VER = 0x00100515,
	FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_MACHINE_AUTHZ_ON_TUNNEL = 0x00100516,
	FW_RULE_STATUS_SEMANTIC_ERROR_TRANSPORT_USER_AUTHZ_ON_TUNNEL = 0x00100517,
	FW_RULE_STATUS_SEMANTIC_ERROR_PER_RULE_AND_GLOBAL_AUTHZ = 0x00100518,
	FW_RULE_STATUS_SEMANTIC_ERROR_FLAGS_SECURITY_REALM = 0x00100519,
	FW_RULE_STATUS_SEMANTIC_ERROR_SET_ID = 0x00101000,
	FW_RULE_STATUS_SEMANTIC_ERROR_IPSEC_PHASE = 0x00101010,
	FW_RULE_STATUS_SEMANTIC_ERROR_EMPTY_SUITES = 0x00101020,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_AUTH_METHOD = 0x00101030,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_AUTH_METHOD = 0x00101031,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_ANONYMOUS = 0x00101032,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_DUPLICATE = 0x00101033,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_METHOD_VER = 0x00101034,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_SUITE_FLAGS = 0x00101040,
	FW_RULE_STATUS_SEMANTIC_ERROR_HEALTH_CERT = 0x00101041,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_SIGNCERT_VER = 0x00101042,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_INTERMEDIATE_CA_VER = 0x00101043,
	FW_RULE_STATUS_SEMANTIC_ERROR_MACHINE_SHKEY = 0x00101050,
	FW_RULE_STATUS_SEMANTIC_ERROR_CA_NAME = 0x00101060,
	FW_RULE_STATUS_SEMANTIC_ERROR_MIXED_CERTS = 0x00101061,
	FW_RULE_STATUS_SEMANTIC_ERROR_NON_CONTIGUOUS_CERTS = 0x00101062,
	FW_RULE_STATUS_SEMANTIC_ERROR_MIXED_CA_TYPE_IN_BLOCK = 0x00101063,
	FW_RULE_STATUS_SEMANTIC_ERROR_MACHINE_USER_AUTH = 0x00101070,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_VER = 0x00101071,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_VER_MISMATCH = 0x00101072,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_RENEWAL_HASH = 0x00101073,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_HASH = 0x00101074,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_EKU = 0x00101075,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_NAME_TYPE = 0x00101076,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_NAME = 0x00101077,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_INVALID_CRITERIA_TYPE = 0x00101078,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_CERT_CRITERIA_MISSING_CRITERIA = 0x00101079,
	FW_RULE_STATUS_SEMANTIC_ERROR_PROXY_SERVER = 0x00101080,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_PROXY_SERVER_VER = 0x00101081,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_NON_DEFAULT_ID = 0x00105000,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_FLAGS = 0x00105001,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_TIMEOUT_MINUTES = 0x00105002,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_TIMEOUT_SESSIONS = 0x00105003,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_KEY_EXCHANGE = 0x00105004,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_ENCRYPTION = 0x00105005,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_HASH = 0x00105006,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_ENCRYPTION_VER = 0x00105007,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_HASH_VER = 0x00105008,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE1_CRYPTO_KEY_EXCH_VER = 0x00105009,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PFS = 0x00105020,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PROTOCOL = 0x00105021,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_ENCRYPTION = 0x00105022,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_HASH = 0x00105023,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_TIMEOUT_MINUTES = 0x00105024,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_TIMEOUT_KBYTES = 0x00105025,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_ENCRYPTION_VER = 0x00105026,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_HASH_VER = 0x00105027,
	FW_RULE_STATUS_SEMANTIC_ERROR_PHASE2_CRYPTO_PFS_VER = 0x00105028,
	FW_RULE_STATUS_SEMANTIC_ERROR_CRYPTO_ENCR_HASH = 0x00105040,
	FW_RULE_STATUS_SEMANTIC_ERROR_CRYPTO_ENCR_HASH_COMPAT = 0x00105041,
	FW_RULE_STATUS_SEMANTIC_ERROR_SCHEMA_VERSION = 0x00105050,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_OR_AND_CONDITIONS = 0x00106000,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_AND_CONDITIONS = 0x00106001,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_KEY = 0x00106002,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_MATCH_TYPE = 0x00106003,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_DATA_TYPE = 0x00106004,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_CONDITION_KEY_AND_DATA_TYPE = 0x00106005,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEYS_PROTOCOL_PORT = 0x00106006,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_PROFILE = 0x00106007,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_STATUS = 0x00106008,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_FILTERID = 0x00106009,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_APP_PATH = 0x00106010,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_PROTOCOL = 0x00106011,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_LOCAL_PORT = 0x00106012,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_REMOTE_PORT = 0x00106013,
	FW_RULE_STATUS_SEMANTIC_ERROR_QUERY_KEY_SVC_NAME = 0x00106015,
	FW_RULE_STATUS_SEMANTIC_ERROR_REQUIRE_IN_CLEAR_OUT_ON_TRANSPORT = 0x00107000,
	FW_RULE_STATUS_SEMANTIC_ERROR_TUNNEL_BYPASS_TUNNEL_IF_SECURE_ON_TRANSPORT = 0x00107001,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_NOENCAP_ON_TUNNEL = 0x00107002,
	FW_RULE_STATUS_SEMANTIC_ERROR_AUTH_NOENCAP_ON_PSK = 0x00107003,
	FW_RULE_STATUS_RUNTIME_ERROR = 0x00200000,
	FW_RULE_STATUS_RUNTIME_ERROR_PHASE1_AUTH_NOT_FOUND = 0x00200001,
	FW_RULE_STATUS_RUNTIME_ERROR_PHASE2_AUTH_NOT_FOUND = 0x00200002,
	FW_RULE_STATUS_RUNTIME_ERROR_PHASE2_CRYPTO_NOT_FOUND = 0x00200003,
	FW_RULE_STATUS_RUNTIME_ERROR_AUTH_MCHN_SHKEY_MISMATCH = 0x00200004,
	FW_RULE_STATUS_RUNTIME_ERROR_PHASE1_CRYPTO_NOT_FOUND = 0x00200005,
	FW_RULE_STATUS_RUNTIME_ERROR_AUTH_NOENCAP_ON_TUNNEL = 0x00200006,
	FW_RULE_STATUS_RUNTIME_ERROR_AUTH_NOENCAP_ON_PSK = 0x00200007,
	FW_RULE_STATUS_RUNTIME_ERROR_KEY_MODULE_AUTH_MISMATCH = 0x00200008,
	FW_RULE_STATUS_ERROR = FW_RULE_STATUS_PARSING_ERROR | FW_RULE_STATUS_SEMANTIC_ERROR | FW_RULE_STATUS_RUNTIME_ERROR,
	FW_RULE_STATUS_ALL = 0xFFFF0000
} FW_RULE_STATUS;

typedef enum _tag_FW_RULE_ORIGIN_TYPE
{
	FW_RULE_ORIGIN_INVALID = 0,
	FW_RULE_ORIGIN_LOCAL = 1,
	FW_RULE_ORIGIN_GP = 2,
	FW_RULE_ORIGIN_DYNAMIC = 3,
	FW_RULE_ORIGIN_AUTOGEN = 4,
	FW_RULE_ORIGIN_HARDCODED = 5,
	FW_RULE_ORIGIN_MAX = 6
} FW_RULE_ORIGIN_TYPE;

typedef enum _tag_FW_ENFORCEMENT_STA
{
	FW_ENFORCEMENT_STATE_INVALID = 0,
	FW_ENFORCEMENT_STATE_FULL = 1,
	FW_ENFORCEMENT_STATE_WF_OFF_IN_PROFILE = 2,
	FW_ENFORCEMENT_STATE_CATEGORY_OFF = 3,
	FW_ENFORCEMENT_STATE_DISABLED_OBJECT = 4,
	FW_ENFORCEMENT_STATE_INACTIVE_PROFILE = 5,
	FW_ENFORCEMENT_STATE_LOCAL_ADDRESS_RESOLUTION_EMPTY = 6,
	FW_ENFORCEMENT_STATE_REMOTE_ADDRESS_RESOLUTION_EMPTY = 7,
	FW_ENFORCEMENT_STATE_LOCAL_PORT_RESOLUTION_EMPTY = 8,
	FW_ENFORCEMENT_STATE_REMOTE_PORT_RESOLUTION_EMPTY = 9,
	FW_ENFORCEMENT_STATE_INTERFACE_RESOLUTION_EMPTY = 10,
	FW_ENFORCEMENT_STATE_APPLICATION_RESOLUTION_EMPTY = 12,
	FW_ENFORCEMENT_STATE_REMOTE_MACHINE_EMPTY = 12,
	FW_ENFORCEMENT_STATE_REMOTE_USER_EMPTY = 13,
	FW_ENFORCEMENT_STATE_LOCAL_GLOBAL_OPEN_PORTS_DISALLOWED = 14,
	FW_ENFORCEMENT_STATE_LOCAL_AUTHORIZED_APPLICATIONS_DISALLOWED = 15,
	FW_ENFORCEMENT_STATE_LOCAL_FIREWALL_RULES_DISALLOWED = 16,
	FW_ENFORCEMENT_STATE_LOCAL_CONSEC_RULES_DISALLOWED = 17,
	FW_ENFORCEMENT_STATE_MISMATCHED_PLATFORM = 18,
	FW_ENFORCEMENT_STATE_OPTIMIZED_OUT = 19,
	FW_ENFORCEMENT_STATE_LOCAL_USER_EMPTY = 20,
	FW_ENFORCEMENT_STATE_TRANSPORT_MACHINE_SD_EMPTY = 21,
	FW_ENFORCEMENT_STATE_TRANSPORT_USER_SD_EMPTY = 22,
	FW_ENFORCEMENT_STATE_TUPLE_RESOLUTION_EMPTY = 23,
	FW_ENFORCEMENT_STATE_DUPLICATE = 24,
	FW_ENFORCEMENT_STATE_MAX = 25
} FW_ENFORCEMENT_STATE;

typedef struct _tag_FW_OBJECT_METADATA
{
	unsigned __int64 qwFilterContextID;
	DWORD dwNumEntries;
	FW_ENFORCEMENT_STATE* pEnforcementStates;
} FW_OBJECT_METADATA, *PFW_OBJECT_METADATA;

typedef struct _tag_FW_NETWORK_NAMES
{
	DWORD dwNumEntries;
	LPWSTR* wszNames;
} FW_NETWORK_NAMES, *PFW_NETWORK_NAMES;

typedef struct _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST
{
	DWORD dwNumIds;
	UINT32* ids;
} FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST, *PFW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST;

typedef struct _tag_FW_RULE
{
	struct _tag_FW_RULE* pNext;
	unsigned short wSchemaVersion;
	wchar_t* wszRuleId;
	wchar_t* wszName;
	wchar_t* wszDescription;
	unsigned long dwProfiles;
	FW_DIRECTION Direction;
	unsigned short wIpProtocol;

	union
	{
		struct
		{
			FW_PORTS LocalPorts;
			FW_PORTS RemotePorts;
		};

		FW_ICMP_TYPE_CODE_LIST V4TypeCodeList;
		FW_ICMP_TYPE_CODE_LIST V6TypeCodeList;
	};

	FW_ADDRESSES LocalAddresses;
	FW_ADDRESSES RemoteAddresses;
	FW_INTERFACE_LUIDS LocalInterfaceIds;
	unsigned long dwLocalInterfaceTypes;
	wchar_t* wszLocalApplication;
	wchar_t* wszLocalService;
	FW_RULE_ACTION Action;
	unsigned short wFlags;
	wchar_t* wszRemoteMachineAuthorizationList;
	wchar_t* wszRemoteUserAuthorizationList;
	wchar_t* wszEmbeddedContext;
	FW_OS_PLATFORM_LIST PlatformValidityList;
	FW_RULE_STATUS Status;
	FW_RULE_ORIGIN_TYPE Origin;
	wchar_t* wszGPOName;
	unsigned long Reserved;
	PFW_OBJECT_METADATA pMetaData;
	WCHAR* wszLocalUserAuthorizationList;
	WCHAR* wszPackageId;
	WCHAR* wszLocalUserOwner;
	unsigned long dwTrustTupleKeywords;
	FW_NETWORK_NAMES OnNetworkNames;
	WCHAR* wszSecurityRealmId;
	unsigned short wFlags2;

	//this is how I see it
	GUID providerContextKey;
	FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST RemoteDynamicKeywordAddresses;
	FW_NETWORK_NAMES RemoteOutServerNames;
	WCHAR* wszFqbn;
	unsigned long compartmentId;

	// this is what Microsoft says
	//FW_NETWORK_NAMES RemoteOutServerNames;
	//WCHAR* wszFqbn;
	//unsigned long compartmentId;
	//GUID providerContextKey;
	//FW_DYNAMIC_KEYWORD_ADDRESS_ID_LIST RemoteDynamicKeywordAddresses;
} FW_RULE, *PFW_RULE;

typedef HRESULT (*FWOPENOFFLINEPOLICYSTORE)(HKEY, FW_STORE_TYPE, FW_POLICY_ACCESS_RIGHT, FW_IO_POLICY_STORE_HANDLE*);

HRESULT
FwOpenOfflinePolicyStore(
	HKEY hBaseKey,
	FW_STORE_TYPE StoreType,
	FW_POLICY_ACCESS_RIGHT AccessRight,
	FW_IO_POLICY_STORE_HANDLE* pHandle
)
{
	static FWOPENOFFLINEPOLICYSTORE pfnFwOpenOfflinePolicyStore = NULL;
	if (NULL == pfnFwOpenOfflinePolicyStore)
	{
		pfnFwOpenOfflinePolicyStore = (FWOPENOFFLINEPOLICYSTORE)(LPVOID)
			GetProcAddress(hFwpolicyiomgrDLL, "FwOpenOfflinePolicyStore");
	}
	if (NULL == pfnFwOpenOfflinePolicyStore)
	{
		_tprintf(_T("FwOpenOfflinePolicyStore could not be found.\r\n"));
		_exit(ERROR_PROC_NOT_FOUND);
	}
	return pfnFwOpenOfflinePolicyStore(hBaseKey, StoreType, AccessRight, pHandle);
}


typedef HRESULT (*FWCLOSEPOLICYSTORE)(FW_IO_POLICY_STORE_HANDLE);

HRESULT
FwClosePolicyStore(
	FW_IO_POLICY_STORE_HANDLE handle
)
{
	static FWCLOSEPOLICYSTORE pfnFwClosePolicyStore = NULL;
	if (NULL == pfnFwClosePolicyStore)
	{
		pfnFwClosePolicyStore = (FWCLOSEPOLICYSTORE)(LPVOID)GetProcAddress(hFwpolicyiomgrDLL, "FwClosePolicyStore");
	}
	if (NULL == pfnFwClosePolicyStore)
	{
		_tprintf(_T("FwClosePolicyStore could not be found.\r\n"));
		_exit(ERROR_PROC_NOT_FOUND);
	}
	return pfnFwClosePolicyStore(handle);
}


typedef HRESULT (*FWENUMRULES)(FW_IO_POLICY_STORE_HANDLE, FW_RULE_TYPE, FW_BLOB_RULE**, DWORD*, DWORD, DWORD, DWORD);

HRESULT
FwEnumRules(
	FW_IO_POLICY_STORE_HANDLE handle,
	FW_RULE_TYPE RuleType,
	FW_BLOB_RULE** ppRules,
	DWORD* lpdwNumRules,
	DWORD dwFilteredByStatus,
	DWORD dwFilteredByProfile,
	DWORD dwFlags // Bit-flags from ENUM_RULES_FLAGS
)
{
	static FWENUMRULES pfnFwEnumRules = NULL;
	if (NULL == pfnFwEnumRules)
	{
		pfnFwEnumRules = (FWENUMRULES)(LPVOID)GetProcAddress(hFwpolicyiomgrDLL, "FwEnumRules");
	}
	if (NULL == pfnFwEnumRules)
	{
		_tprintf(_T("FwEnumRules could not be found.\r\n"));
		_exit(ERROR_PROC_NOT_FOUND);
	}
	return pfnFwEnumRules(handle, RuleType, ppRules, lpdwNumRules, dwFilteredByStatus, dwFilteredByProfile, dwFlags);
}


BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege)
{
	TOKEN_PRIVILEGES tp;
	LUID luid;
	BOOL bStatus;

	bStatus = LookupPrivilegeValue(NULL, lpszPrivilege, &luid);
	if (!bStatus)
	{
		_tprintf(_T("\r\nERROR: LookupPrivilegeValue() returned %lu\r\n"), GetLastError());
		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	bStatus = AdjustTokenPrivileges(
		hToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		(PTOKEN_PRIVILEGES)NULL,
		(PDWORD)NULL);
	if (!bStatus)
	{
		_tprintf(_T("\r\nERROR: AdjustTokenPrivileges() returned %lu\r\n"), GetLastError());
		return FALSE;
	}

	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
	{
		_tprintf(_T("\r\nERROR: The token does not have the specified privilege.\r\n"));
		return FALSE;
	}
	return TRUE;
}


VOID PrintRule(PFW_RULE pfwRule)
{
	_tprintf(_T("Rule ID: %ls\r\n"), pfwRule->wszRuleId);
	_tprintf(_T("\tName: %ls\r\n"), pfwRule->wszName);
	_tprintf(_T("\tDescription: %ls\r\n"), pfwRule->wszDescription);
	_tprintf(_T("\tGroup: %ls\r\n"), pfwRule->wszEmbeddedContext);
	_tprintf(_T("\tEnabled: %s\r\n"), (0 == (pfwRule->wFlags & FW_RULE_FLAGS_ACTIVE)) ? _T("No") : _T("Yes"));
	_tprintf(_T("\tAction (2=BLOCK, 3=ALLOW): %i\r\n"), pfwRule->Action);
	_tprintf(_T("\tDirection (1=IN, 2=OUT): %i\r\n"), pfwRule->Direction);
	_tprintf(_T("\tProtocol (256=ALL): %u\r\n"), pfwRule->wIpProtocol);
	_tprintf(_T("\tProfiles (1=DOMAIN, 2=PRIVATE, 4=PUBLIC, 2147483647=ALL): %i\r\n"), pfwRule->dwProfiles);
	_tprintf(_T("\tApplication: %ls\r\n"), pfwRule->wszLocalApplication);
	_tprintf(_T("\tService: %ls\r\n"), pfwRule->wszLocalService);
	_tprintf(_T("\tAppPackage: %ls\r\n"), pfwRule->wszPackageId);

	if (0 != pfwRule->LocalAddresses.V4Ranges.dwNumEntries)
	{
		_tprintf(_T("\tLocal IPv4 Addres Ranges:\r\n"));
		for (unsigned long i = 0; i < pfwRule->LocalAddresses.V4Ranges.dwNumEntries; i++)
		{
			_tprintf(
				_T("\t\tRange[%u]: %08x-%08x\r\n"),
				i,
				pfwRule->LocalAddresses.V4Ranges.pRanges[i].dwBegin,
				pfwRule->LocalAddresses.V4Ranges.pRanges[i].dwEnd);
		}
	}

	if (0 != pfwRule->LocalAddresses.V4SubNets.dwNumEntries)
	{
		_tprintf(_T("\tLocal IPv4 Subnets:\r\n"));
		for (unsigned long i = 0; i < pfwRule->LocalAddresses.V4SubNets.dwNumEntries; i++)
		{
			_tprintf(
				_T("\t\tSubnet[%u]: %08x:%08x\r\n"),
				i,
				pfwRule->LocalAddresses.V4SubNets.pSubNets[i].dwAddress,
				pfwRule->LocalAddresses.V4SubNets.pSubNets[i].dwSubNetMask);
		}
	}

	if (0 != pfwRule->RemoteAddresses.V4Ranges.dwNumEntries)
	{
		_tprintf(_T("\tRemote IPv4 Addres Ranges:\r\n"));
		for (unsigned long i = 0; i < pfwRule->RemoteAddresses.V4Ranges.dwNumEntries; i++)
		{
			_tprintf(
				_T("\t\tRange[%u]: %08x-%08x\r\n"),
				i,
				pfwRule->RemoteAddresses.V4Ranges.pRanges[i].dwBegin,
				pfwRule->RemoteAddresses.V4Ranges.pRanges[i].dwEnd);
		}
	}

	if (0 != pfwRule->RemoteAddresses.V4SubNets.dwNumEntries)
	{
		_tprintf(_T("\tRemote IPv4 Subnets:\r\n"));
		for (unsigned long i = 0; i < pfwRule->RemoteAddresses.V4SubNets.dwNumEntries; i++)
		{
			_tprintf(
				_T("\t\tSubnet[%u]: %08x:%08x\r\n"),
				i,
				pfwRule->RemoteAddresses.V4SubNets.pSubNets[i].dwAddress,
				pfwRule->RemoteAddresses.V4SubNets.pSubNets[i].dwSubNetMask);
		}
	}

	//not parsing, just letting you know
	if (0 != pfwRule->LocalAddresses.V6Ranges.dwNumEntries ||
		0 != pfwRule->LocalAddresses.V6SubNets.dwNumEntries ||
		0 != pfwRule->RemoteAddresses.V6Ranges.dwNumEntries ||
		0 != pfwRule->RemoteAddresses.V6SubNets.dwNumEntries)
	{
		_tprintf(_T("\tIPv6 Address rules exist.\r\n"));
	}

	if (TCP_PROTOCOL_NUMBER == pfwRule->wIpProtocol || UDP_PROTOCOL_NUMBER == pfwRule->wIpProtocol)
	{
		if (0 != pfwRule->LocalPorts.Ports.dwNumEntries)
		{
			_tprintf(_T("\tLocal Ports:\r\n"));
			for (unsigned long i = 0; i < pfwRule->LocalPorts.Ports.dwNumEntries; i++)
			{
				_tprintf(
					_T("\t\tRange[%u]: %u-%u\r\n"),
					i,
					pfwRule->LocalPorts.Ports.pPorts[i].wBegin,
					pfwRule->LocalPorts.Ports.pPorts[i].wEnd);
			}
		}
		if (0 != pfwRule->RemotePorts.Ports.dwNumEntries)
		{
			_tprintf(_T("\tRemote Ports:\r\n"));
			for (unsigned long i = 0; i < pfwRule->RemotePorts.Ports.dwNumEntries; i++)
			{
				_tprintf(
					_T("\t\tRange[%u]: %u-%u\r\n"),
					i,
					pfwRule->RemotePorts.Ports.pPorts[i].wBegin,
					pfwRule->RemotePorts.Ports.pPorts[i].wEnd);
			}
		}
	}

	_tprintf(_T("\r\n"));
}


int _tmain(int argc, _TCHAR** argv, _TCHAR** envp)
{
	UNREFERENCED_PARAMETER(envp);
	BOOL bStatus;
	LSTATUS lsStatus;
	DWORD dwStatus;
	HRESULT hr;
	HKEY hkOfflineSystemKey;
	HANDLE currentTokenHandle;
	FW_IO_POLICY_STORE_HANDLE fwpHandle = NULL;
	//WF_POLICY_STORE

	bStatus = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &currentTokenHandle);
	if (!bStatus)
	{
		dwStatus = GetLastError();
		_tprintf(_T("ERROR: OpenProcessToken() returned %lu"), dwStatus);
		return (int)dwStatus;
	}

	bStatus = SetPrivilege(currentTokenHandle, SE_BACKUP_NAME);
	if (!bStatus)
	{
		dwStatus = GetLastError();
		_tprintf(_T("ERROR: SetPrivilege(SE_BACKUP_NAME) returned %lu"), dwStatus);
		CloseHandle(currentTokenHandle);
		return (int)dwStatus;
	}

	bStatus = SetPrivilege(currentTokenHandle, SE_RESTORE_NAME);
	if (!bStatus)
	{
		dwStatus = GetLastError();
		_tprintf(_T("ERROR: SetPrivilege(SE_RESTORE_NAME) returned %lu"), dwStatus);
		CloseHandle(currentTokenHandle);
		return (int)dwStatus;
	}

	if (2 != argc)
	{
		WCHAR pwszFileName[MAX_PATH];
		_wsplitpath_s(argv[0], NULL, 0, NULL, 0, pwszFileName, ARRAYSIZE(pwszFileName), NULL, 0);
		wprintf(L"\r\nUsage: %s SYSTEM\r\n", pwszFileName);
		return (-1);
	}

	hFwpolicyiomgrDLL = LoadLibrary(_T("fwpolicyiomgr.dll"));
	if (NULL == hFwpolicyiomgrDLL)
	{
		dwStatus = GetLastError();
		_tprintf(_T("\r\nCannot load fwpolicyiomgr.dll. Error %i\r\n"), dwStatus);
		return ((int)dwStatus);
	}


	lsStatus = RegLoadKey(HKEY_LOCAL_MACHINE, GUID_1, argv[1]);
	if (ERROR_SUCCESS != lsStatus)
	{
		_tprintf(_T("\r\nERROR: RegLoadKey() returned %i\r\n"), lsStatus);
		return ((int)lsStatus);
	}

	lsStatus = RegOpenKey(HKEY_LOCAL_MACHINE, GUID_1, &hkOfflineSystemKey);
	if (ERROR_SUCCESS != lsStatus)
	{
		_tprintf(_T("\r\nERROR: RegOpenKey() returned %i\r\n"), lsStatus);
		RegUnLoadKey(HKEY_LOCAL_MACHINE, GUID_1);
		return ((int)lsStatus);
	}

	hr = FwOpenOfflinePolicyStore(hkOfflineSystemKey, FW_STORE_TYPE_LOCAL, FW_POLICY_ACCESS_RIGHT_READ, &fwpHandle);
	if (S_OK == hr)
	{
		PFW_RULE pfwRule;
		DWORD dwRulesCount;

		hr = FwEnumRules(
			fwpHandle,
			FW_RULE_TYPE_FIREWALL,
			(PFW_BLOB_RULE*)&pfwRule,
			&dwRulesCount,
			FW_RULE_STATUS_ALL,
			FW_PROFILE_TYPE_ALL,
			0);
		if (S_OK == hr)
		{
			_tprintf(_T("%i rules found.\r\n"), dwRulesCount);
			while (NULL != pfwRule)
			{
				PrintRule(pfwRule);
				pfwRule = pfwRule->pNext;
			}
		}
		else
		{
			_tprintf(_T("\r\nERROR: FwEnumRules() returned %i\r\n"), hr);
		}
	}
	else
	{
		_tprintf(_T("\r\nERROR: FwOpenOfflinePolicyStore() returned %i\r\n"), hr);
	}

	hr = FwClosePolicyStore(fwpHandle);
	if (S_OK != hr)
	{
		_tprintf(_T("\r\nERROR: FwClosePolicyStore() returned %i\r\n"), hr);
	}


	lsStatus = RegCloseKey(hkOfflineSystemKey);
	if (ERROR_SUCCESS != lsStatus)
	{
		_tprintf(_T("\r\nERROR: RegOpenKey() returned %i\r\n"), lsStatus);
		RegUnLoadKey(HKEY_LOCAL_MACHINE, GUID_1);
		return ((int)lsStatus);
	}

	lsStatus = RegUnLoadKey(HKEY_LOCAL_MACHINE, GUID_1);
	if (ERROR_SUCCESS != lsStatus)
	{
		_tprintf(_T("\r\nERROR: RegUnLoadKey() returned %i\r\n"), lsStatus);
		return ((int)lsStatus);
	}
}
